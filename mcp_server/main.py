# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T15:53:41+00:00



import argparse
import json
import os
from datetime import datetime
from typing import *
from typing import Optional, Union
from uuid import UUID

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import APIKeyHeader, BaseSecurity
from fastapi import Query
from pydantic import conint

from models import (
    AdDealStatus,
    ClassificationInclusionsGetResponse,
    ClassificationInclusionsGetResponse1,
    ClassificationInclusionsIdGetResponse,
    ClassificationsGetResponse,
    ClassificationsGetResponse1,
    ClassificationsIdGetResponse,
    ClassificationType,
    ClassifiedType,
    CreditableType,
    CreditsGetResponse,
    CreditsGetResponse1,
    CreditsIdGetResponse,
    EpisodesGetResponse,
    EpisodesGetResponse1,
    EpisodesIdGetResponse,
    EpisodesIdNextSiblingGetResponse,
    EpisodesIdPreviousSiblingGetResponse,
    Ids,
    ImagesGetResponse,
    ImagesGetResponse1,
    ImagesIdGetResponse,
    MediaAssetsGetResponse,
    MediaAssetsGetResponse1,
    MediaAssetsIdGetResponse,
    NetworksGetResponse,
    NetworksGetResponse1,
    NetworksIdGetResponse,
    PeopleGetResponse,
    PeopleGetResponse1,
    PeopleIdGetResponse,
    SeasonsGetResponse,
    SeasonsGetResponse1,
    SeasonsIdGetResponse,
    SeriesGetResponse,
    SeriesGetResponse1,
    SeriesIdGetResponse,
    Sort,
    Sort1,
    Sort2,
    Sort3,
    Sort4,
    Sort5,
    Sort6,
    Sort7,
    Type3,
)

app = MCPProxy(
    contact={
        'email': 'support@art19.com',
        'name': 'ART19 Engineering Team',
        'x-twitter': 'art19co',
    },
    description='The ART19 Content API conforms to the [JSON:API specification](http://jsonapi.org).\n\nAPI requests **MUST** use the HTTP Accept header:\n\n`Accept: application/vnd.api+json`\n\nAPI requests **MUST** be authenticated using the HTTP Authorization header:\n\n`Authorization: Token token="your-token", credential="your-credential"`\n\n## General Notes\n\nSome query parameters use unencoded [ and ] characters simply for readability. Defaults, examples, and\npossible values are additionally rendered in double quotes for readability. In practice, query parameters should\nnot have quotes around the values (e.g., `foo=bar` is valid, not `foo="bar"`), and both query parameter keys\nand values must be percent-encoded, per the requirements in [RFC 3986 ยง 3.4](https://tools.ietf.org/html/rfc3986#section-3.4).\n\n## Rate Limiting\n\nIn order to provide a fair distribution of available resources, all API calls are subject to rate limits.\nIf you exceed the number of API calls per minute granted to your credential, a `429 Too Many Requests`\nerror response will be returned.\n\nIn that case, a `Retry-After` header MAY be included in the response, describing the number of seconds\nafter which a request can be retried.\n\nIf you run into a high number of 429 errors, please reach out to ART19 Support to adjust your rate limit.\n\n### Example\n\nIn the following example the request can be retried after waiting for 21 seconds:\n\n    HTTP/1.1 429 Too Many Requests\n    Content-Type: text/html\n    Retry-After: 21\n\n## Pagination\n\nRequests to collection endpoints **SHOULD** provide pagination parameters.\nSome endpoints **REQUIRE** pagination parameters to be provided.\nWhenever pagination is provided, it **MUST** be valid.\nFailing to provide pagination when it is required or providing wrong or incomplete pagination\nalways results in a `400 Bad Request` error response.\n\nThe page numbering starts with `1` and the maximum page size (if not otherwise documented\non an endpoint) is `100`. Pagination **MUST NOT** be specified if requesting a list of IDs (using an `ids[]` parameter).\n\nProviding invalid values for page number or page size, as well as providing only a page number or only a page size,\nis considered an error. Pagination is provided like this:\n\n`page[number]=1&page[size]=25`\n\nResponses conform to the [JSON:API specification\'s pagination section](https://jsonapi.org/format/#fetching-pagination)\nby including pagination links. Your requested page size will be carried into the pagination links.\n\n## Sorting\n\nRequests to collection endpoints usually accept a `sort` parameter. Please refer to the\n[JSON:API Specification\'s sorting section](https://jsonapi.org/format/#fetching-sorting) for further details.\n\n## Relationship Linking\n\nCurrently, resources return all of their relationships, in no particular order, pursuant to how relationships\nshould be returned [according to the JSON:API specification](https://jsonapi.org/format/#document-resource-object-relationships). Consumers of this API\n**MUST NOT** make assumptions about the order of these collections. Even though this data is not currently paginated, consumers **MUST** support\npaginating relationships per the JSON:API specification if this data is important for their application.\n',
    termsOfService='https://art19.com/business-terms',
    title='ART19 Content API Documentation',
    version='1.0.0',
    servers=[{'url': 'https://art19.com'}],
)


@app.get(
    '/classification_inclusions',
    description=""" Classification Inclusions connect classifications with entities like series, episodes, or campaigns, amongst others.

In order to retrieve a set of classification inclusions, at least one of the following filter parameters must
be provided. Failing to do so renders a `400 Bad Request` response.

- `ids[]`
- `classified_id` and `classified_type`
- `classified_id` and `classification_type`
- `classification_id` and `classified_type`
 """,
    tags=['classification_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_classification_inclusions(
    ids__: Optional[Ids] = Query(None, alias='ids[]'),
    page_number_: Optional[conint(ge=1)] = Query(None, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=100)] = Query(None, alias='page[size]'),
    classification_id: Optional[UUID] = None,
    classification_type: Optional[ClassificationType] = None,
    classified_id: Optional[UUID] = None,
    classified_type: Optional[ClassifiedType] = None,
    q: Optional[str] = None,
    sort: Optional[Sort] = 'created_at',
):
    """
    Get ClassificationInclusion records
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/classification_inclusions/{id}',
    tags=['classification_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_classification_inclusions__id(id: UUID):
    """
    Get a specific classification inclusion
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/classifications',
    tags=['classification_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_classifications(
    ids__: Optional[Ids] = Query(None, alias='ids[]'),
    page_number_: Optional[conint(ge=1)] = Query(None, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=100)] = Query(None, alias='page[size]'),
    type: Optional[Type3] = None,
    q: Optional[str] = None,
    is_country: Optional[str] = None,
    sort: Optional[Sort1] = 'value',
):
    """
    Get a list of classifications
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/classifications/{id}',
    tags=['classification_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_classifications__id(id: UUID):
    """
    Get a specific classification
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/credits',
    tags=['credit_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_credits(
    ids__: Optional[Ids] = Query(None, alias='ids[]'),
    page_number_: Optional[conint(ge=1)] = Query(None, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=100)] = Query(None, alias='page[size]'),
    creditable_id: Optional[UUID] = None,
    creditable_type: Optional[CreditableType] = None,
    sort: Optional[Sort2] = 'position',
):
    """
    Get a list of credits
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/credits/{id}',
    tags=['credit_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_credits__id(id: UUID):
    """
    Get a specific credit
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/episodes',
    description=""" One initial filter must be provided (`ids`, `series_id`, or `season_id`), otherwise a `400 Bad Request` response
will be returned. Additional filters are allowed.

This API will only return episodes that your credential has permission to access, which may not be exclusive to
your account, depending on the filter(s) being used. Be careful to filter the results as needed.
 """,
    tags=['episode_handling', 'season_handling', 'series_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_episodes(
    ids__: Optional[Ids] = Query(None, alias='ids[]'),
    page_number_: conint(ge=1) = Query(..., alias='page[number]'),
    page_size_: conint(ge=1, le=100) = Query(..., alias='page[size]'),
    included_in_inventory_calendar: Optional[UUID] = None,
    month: Optional[str] = None,
    published: Optional[bool] = None,
    q: Optional[str] = None,
    released_after: Optional[datetime] = None,
    released_before: Optional[datetime] = None,
    rss: Optional[bool] = None,
    season_id: Optional[UUID] = None,
    series_id: Optional[UUID] = None,
    sort: Optional[Sort3] = 'sort_title',
    year: Optional[str] = None,
):
    """
    Get a list of episodes
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/episodes/{id}',
    tags=['episode_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_episodes__id(id: UUID):
    """
    Get a specific episode
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/episodes/{id}/next_sibling',
    tags=['episode_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_episodes__id_next_sibling(id: UUID, rss: Optional[bool] = None):
    """
    Get the episode released right after the specified one
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/episodes/{id}/previous_sibling',
    tags=['episode_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_episodes__id_previous_sibling(id: UUID, rss: Optional[bool] = None):
    """
    Get the episode released right before the specified one
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/images',
    description=""" An image represents a piece of artwork attached to some entity like a series, season, or episode,
and is _owned_ by an entity called the `bucket`.
An image is also a container for several `MediaAssets` representing the physical files for various
styles used.

## Media Asset Styles for Images

Most media assets use square images. You may upload and use a square image, or upload an image of any
shape and crop it to a square by specifying the cropping area. This area โ identified by a coordinate
`x, y` and a `width` & `height` โ is the portion of the image used for all cover art. If an image has
cropping defined, the cropped version of the image will be used in any `regular` or `square` style of media
asset. If the original file is rectangular and does not have cropping, then the system will use a squared
version of the original file with the smaller of width or height as the square size.

The original image as uploaded into the system is always retained unmodified and available through
the style `original`. All media asset styles except `stripped-original` consist of the cropped image.

An image has media assets with the following styles:

- `original`: This is the original file provided. May not be available, depending on permissions
  and file type.
- `stripped-original`: The original file with all metadata (EXIF, XMP, PNG metadata, etc.) removed.
  This should be used for any application needing the original, uncropped, image.
- `regular`: If the image has cropping defined, this is the cropped image.
  If not, this is a square version of the original.
- `thumb`: A square thumbnail of the image with a size of `100x100` pixels.
- `square-400`: A square version of the image with a size of `400x400` pixels.
- `square-640`: A square version of the image with a size of `640x640` pixels.
- `square-888`: A square version of the image with a size of `888x888` pixels.
- `square-3000`: A square version of the image with a size of `3000x3000` pixels.
  This variant is only created if the cropped width & height are each at least 3000.
- `itunes`: A square version of the image with a size of `1400x1400` pixels.

### Preferred image used in feeds

For the main series image used in feeds, it is ideal to use the `square-3000` version.
If that is not available, the `itunes` version should be used instead.

 """,
    tags=['image_handling', 'media_asset_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_images(ids__: Ids = Query(..., alias='ids[]')):
    """
    Get a list of images
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/images/{id}',
    description=""" An image represents a piece of artwork attached to some entity like a series, season, or episode,
and is _owned_ by an entity called the `bucket`.
An image is also a container for several `MediaAssets` representing the physical files for various
styles used.

## Media Asset Styles for Images

Most media assets use square images. You may upload and use a square image, or upload an image of any
shape and crop it to a square by specifying the cropping area. This area โ identified by a coordinate
`x, y` and a `width` & `height` โ is the portion of the image used for all cover art. If an image has
cropping defined, the cropped version of the image will be used in any `regular` or `square` style of media
asset. If the original file is rectangular and does not have cropping, then the system will use a squared
version of the original file with the smaller of width or height as the square size.

The original image as uploaded into the system is always retained unmodified and available through
the style `original`. All media asset styles except `stripped-original` consist of the cropped image.

An image has media assets with the following styles:

- `original`: This is the original file provided. May not be available, depending on permissions
  and file type.
- `stripped-original`: The original file with all metadata (EXIF, XMP, PNG metadata, etc.) removed.
  This should be used for any application needing the original, uncropped, image.
- `regular`: If the image has cropping defined, this is the cropped image.
  If not, this is a square version of the original.
- `thumb`: A square thumbnail of the image with a size of `100x100` pixels.
- `square-400`: A square version of the image with a size of `400x400` pixels.
- `square-640`: A square version of the image with a size of `640x640` pixels.
- `square-888`: A square version of the image with a size of `888x888` pixels.
- `square-3000`: A square version of the image with a size of `3000x3000` pixels.
  This variant is only created if the cropped width & height are each at least 3000.
- `itunes`: A square version of the image with a size of `1400x1400` pixels.

### Preferred image used in feeds

For the main series image used in feeds, it is ideal to use the `square-3000` version.
If that is not available, the `itunes` version should be used instead.

 """,
    tags=['image_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_images__id(id: UUID):
    """
    Get a specific image
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/media_assets',
    description=""" A media asset is part of a collection of assets or files representing an image or a piece of audio content
like an episode or an ad. Images, for example, have differently sized versions for better rendering performance,
and a piece of audio content usually comes in different encoding formats.

The `style` attribute of a media asset describes the role an asset plays in the context of the collection.
The collection is what an asset is attached to (`attachment_id|type`).

## Styles for Images

Most media assets use square images. You may upload and use a square image, or upload an image of any
shape and crop it to a square by specifying the cropping area. This area โ identified by a coordinate
`x, y` and a `width` & `height` โ is the portion of the image used for all cover art. If an image has
cropping defined, the cropped version of the image will be used in any `regular` or `square` style of media
asset. If the original file is rectangular and does not have cropping, then the system will use a squared
version of the original file with the smaller of width or height as the square size.

The original image as uploaded into the system is always retained unmodified and available through
the style `original`. All media asset styles except `stripped-original` consist of the cropped image.

An image has media assets with the following styles:

- `original`: This is the original file provided. May not be available, depending on permissions
  and file type.
- `stripped-original`: The original file with all metadata (EXIF, XMP, PNG metadata, etc.) removed.
  This should be used for any application needing the original, uncropped, image.
- `regular`: If the image has cropping defined, this is the cropped image.
  If not, this is a square version of the original.
- `thumb`: A square thumbnail of the image with a size of `100x100` pixels.
- `square-400`: A square version of the image with a size of `400x400` pixels.
- `square-640`: A square version of the image with a size of `640x640` pixels.
- `square-888`: A square version of the image with a size of `888x888` pixels.
- `square-3000`: A square version of the image with a size of `3000x3000` pixels.
  This variant is only created if the cropped width & height are each at least 3000.
- `itunes`: A square version of the image with a size of `1400x1400` pixels.

### Preferred image used in feeds

For the main series image used in feeds, it is ideal to use the `square-3000` version.
If that is not available, the `itunes` version should be used instead.


## Styles for Audio

- `medium`: A medium-quality version of the audio asset in various formats.
- `original`: This is the original file provided. May not be available, depending on permissions
  and file type.
- `waveform_data`: The generated BBC Audiowaveform data in JSON or binary format.

 """,
    tags=['media_asset_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_media_assets(ids__: Ids = Query(..., alias='ids[]')):
    """
    Get a list of media assets
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/media_assets/{id}',
    description=""" A media asset is part of a collection of assets or files representing an image or a piece of audio content
like an episode or an ad. Images, for example, have differently sized versions for better rendering performance,
and a piece of audio content usually comes in different encoding formats.

The `style` attribute of a media asset describes the role an asset plays in the context of the collection.
The collection is what an asset is attached to (`attachment_id|type`).

## Styles for Images

Most media assets use square images. You may upload and use a square image, or upload an image of any
shape and crop it to a square by specifying the cropping area. This area โ identified by a coordinate
`x, y` and a `width` & `height` โ is the portion of the image used for all cover art. If an image has
cropping defined, the cropped version of the image will be used in any `regular` or `square` style of media
asset. If the original file is rectangular and does not have cropping, then the system will use a squared
version of the original file with the smaller of width or height as the square size.

The original image as uploaded into the system is always retained unmodified and available through
the style `original`. All media asset styles except `stripped-original` consist of the cropped image.

An image has media assets with the following styles:

- `original`: This is the original file provided. May not be available, depending on permissions
  and file type.
- `stripped-original`: The original file with all metadata (EXIF, XMP, PNG metadata, etc.) removed.
  This should be used for any application needing the original, uncropped, image.
- `regular`: If the image has cropping defined, this is the cropped image.
  If not, this is a square version of the original.
- `thumb`: A square thumbnail of the image with a size of `100x100` pixels.
- `square-400`: A square version of the image with a size of `400x400` pixels.
- `square-640`: A square version of the image with a size of `640x640` pixels.
- `square-888`: A square version of the image with a size of `888x888` pixels.
- `square-3000`: A square version of the image with a size of `3000x3000` pixels.
  This variant is only created if the cropped width & height are each at least 3000.
- `itunes`: A square version of the image with a size of `1400x1400` pixels.

### Preferred image used in feeds

For the main series image used in feeds, it is ideal to use the `square-3000` version.
If that is not available, the `itunes` version should be used instead.


## Styles for Audio

- `medium`: A medium-quality version of the audio asset in various formats.
- `original`: This is the original file provided. May not be available, depending on permissions
  and file type.
- `waveform_data`: The generated BBC Audiowaveform data in JSON or binary format.

 """,
    tags=['media_asset_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_media_assets__id(id: UUID):
    """
    Get a specific media asset
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/networks',
    description=""" ### Deprecations

- The attribute `cover_image_id` has been replaced with the relationship `cover_image`
  and will be removed from the response in a future release.
 """,
    tags=['network_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_networks(
    ids__: Optional[Ids] = Query(None, alias='ids[]'),
    page_number_: Optional[conint(ge=1)] = Query(None, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=100)] = Query(None, alias='page[size]'),
    q: Optional[str] = None,
    ad_rep_account_id: Optional[UUID] = None,
    ad_deal_status: Optional[AdDealStatus] = None,
    sort: Optional[Sort4] = 'name',
):
    """
    Get a list of networks
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/networks/{id}',
    description=""" ### Deprecations

- The attribute `cover_image_id` has been replaced with the relationship `cover_image`
  and will be removed from the response in a future release.
 """,
    tags=['network_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_networks__id(id: UUID):
    """
    Get a specific network
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/people',
    description=""" Each series, season, and episode has a Credits section where you may add people and roles.
This is an internal tool to recognize contributors. It is not related to ART19 users or account permissions.
Each Person added will have no additional access or permissions granted as a result of being included in the Credits section.
 """,
    tags=['person_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_people(
    ids__: Optional[Ids] = Query(None, alias='ids[]'),
    page_number_: Optional[conint(ge=1)] = Query(None, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=100)] = Query(None, alias='page[size]'),
    q: Optional[str] = None,
    sort: Optional[Sort5] = 'last_name,first_name',
):
    """
    Get a list of people
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/people/{id}',
    description=""" Each series, season, and episode has a Credits section where you may add people and roles.
This is an internal tool to recognize contributors. It is not related to ART19 users or account permissions.
Each Person added will have no additional access or permissions granted as a result of being included in the Credits section.
 """,
    tags=['person_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_people__id(id: UUID):
    """
    Get a specific person
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/seasons',
    description=""" When retrieving a list of seasons, the result is automatically filtered depending on the
privileges the used credential holds. If there are no specific privileges to a series or network,
only active seasons for active series are included.
 """,
    tags=['season_handling', 'series_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_seasons(
    ids__: Optional[Ids] = Query(None, alias='ids[]'),
    page_number_: Optional[conint(ge=1)] = Query(None, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=100)] = Query(None, alias='page[size]'),
    series_id: Optional[UUID] = None,
    q: Optional[str] = None,
    sort: Optional[Sort6] = 'sort_title',
):
    """
    Get a list of seasons
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/seasons/{id}',
    tags=['season_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_seasons__id(id: UUID):
    """
    Get a specific season
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/series',
    description=""" When retrieving a list of series, the result is automatically filtered depending on the
privileges the used credential holds. All credentials will have access to active series
with a public page enabled (on ART19). Utilizing a filter to limit the result to series
associated with your account is recommended.
 """,
    tags=['series_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_series(
    ids__: Optional[Ids] = Query(None, alias='ids[]'),
    page_number_: Optional[conint(ge=1)] = Query(None, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=100)] = Query(None, alias='page[size]'),
    ad_rep_account_id: Optional[UUID] = None,
    network_id: Optional[UUID] = None,
    q: Optional[str] = None,
    sort: Optional[Sort7] = 'sort_title',
):
    """
    Get a list of series
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/series/{id}',
    tags=['series_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_series__id(id: UUID):
    """
    Get a specific series
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
